<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_GraphClient_GraphClient.js.html":{"id":"lib_GraphClient_GraphClient.js.html","title":"Source: lib/GraphClient/GraphClient.js","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Source: lib/GraphClient/GraphClient.js // const axios = require(\"axios\"); import axios from \"axios\"; import Fragments from \"./queries/fragments/fragments.json\"; /* istanbul ignore next */ class GraphQLClient { /** The GraphQLClient retrieves data from the FAIRSharing API and sends it to the front-end. * Be careful, this is a singleton and trying to cast new instances will return the existing instance. Be * also careful, its constructor is async !! * @returns {Promise} - to use this object you need to do \"await new ClassName()\" or use .then(callback) */ constructor() { this.initalizeHeader(); if (GraphQLClient._instance) { return GraphQLClient._instance; } GraphQLClient._instance = this; this.url = import.meta.env.VITE_API_ENDPOINT + \"/graphql\"; } /** * Execute the given query (coming from a json file, see /queries/getRecords.json) * @param {Object} query - the query coming from the JSON file * sending to the API. * @returns {Promise} */ async executeQuery(query) { let client = this; let queryString = { query: `{${client.buildQuery(query)}}`, }; let resp = await this.getData(queryString); if (resp.data.errors) { return resp.data.errors; } return resp.data.data; } /** * Takes the query, post it with axios and returns the raw data * @param {Object} queryString - processed request coming out of buildQuery() or a GraphQL query string * @returns {Promise} - an axios promise representing the server response. */ /* v8 ignore start */ async getData(queryString) { let client = this; const fullQuery = { method: \"post\", baseURL: client.url, data: queryString, headers: client.headers, }; return axios(fullQuery); } /* v8 ignore stop */ /** * Transform the JSON query into a string for graphQL * @param {Object} query - the query coming from the JSON file * @returns {Object} {query: queryString} - a valid graphQL query string to execute */ buildQuery(query) { let client = this; let queryString = `${query[\"queryName\"]}`; // query name // Handle query parameters if (query.queryParam) { queryString += \"(\"; Object.keys(query.queryParam).forEach(function (key) { if ( typeof query.queryParam[key] === \"boolean\" || typeof query.queryParam[key] === \"number\" ) { queryString += `${key}:${query.queryParam[key]} `; } else if (typeof query.queryParam[key] === \"string\") { queryString += `${key}:\"${query.queryParam[key]}\" `; } else { let param = []; query.queryParam[key].forEach(function (paramVal) { typeof paramVal !== \"number\" ? param.push('\"' + paramVal + '\"') : param.push(paramVal); }); queryString += `${key}:[${param.join(\",\")}]`; } }); queryString += \")\"; } // Handle query fields if (query.fields) { queryString += \"{\"; query.fields.forEach(function (field) { if (typeof field === \"string\") { queryString += ` ${field}`; } if (typeof field === \"object\") { if (\"$ref\" in field) { let myRef = Fragments[field[\"$ref\"]]; for (let subField of myRef) { if (typeof subField === \"string\") { queryString += ` ${subField}`; /* v8 ignore next 4 */ } else { queryString += ` ${client.buildQuery(subField)}`; } } } else { queryString += ` ${field.name}{`; field.fields.forEach(function (subField) { if (typeof subField === \"string\") { queryString += `${subField} `; } else { queryString += `${client.buildQuery(subField)}`; } }); queryString += \"}\"; } } }); queryString += \"}\"; } return queryString; } /** * Add the authorization token to the headers * @param {String} jwt - the user json web token */ setHeader(jwt) { this.headers[\"Authorization\"] = `Bearer ${jwt}`; } initalizeHeader() { this.headers = { Accept: \"application/json\", \"Content-Type\": \"application/json\", }; this.headers[\"X-Client-Id\"] = import.meta.env.VITE_CLIENT_ID; /* v8 ignore start */ if (this.headers[\"X-Client-Id\"] === undefined) { delete this.headers[\"X-Client-Id\"]; } /* v8 ignore stop */ } } export default GraphQLClient; × Search results Close "},"utils_currentPath.js.html":{"id":"utils_currentPath.js.html","title":"Source: utils/currentPath.js","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Source: utils/currentPath.js /** * @param routeQuery {Object} - route query parameters * @returns {Object} - route query parameters */ const currentPath = (routeQuery) =&gt; { let queryParams = {}; Object.keys(routeQuery).forEach((prop) =&gt; { let queryVal = routeQuery[prop]; if (queryVal) { queryParams[prop] = decodeURI(queryVal); } }); return queryParams; }; export default currentPath; × Search results Close "},"components_Navigation_QuestionPage.vue.html":{"id":"components_Navigation_QuestionPage.vue.html","title":"Source: components/Navigation/QuestionPage.vue","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Source: components/Navigation/QuestionPage.vue &lt;template&gt; &lt;v-container fluid class=\"wrapperClass d-flex flex-column align-content-stretch\" &gt; &lt;v-fade-transition v-if=\"loading\"&gt; &lt;div&gt; &lt;v-overlay v-model=\"loading\" :absolute=\"false\" opacity=\"0.8\" class=\"align-center justify-center\" &gt; &lt;Loaders /&gt; &lt;/v-overlay&gt; &lt;/div&gt; &lt;/v-fade-transition&gt; &lt;!-- how many results so far? --&gt; &lt;ResultPreviewBanner :show-banner=\"Object.keys(getQueryParams).length &gt; 0\" /&gt; &lt;!-- breadcrumb trail --&gt; &lt;Breadcrumbs /&gt; &lt;!-- question title --&gt; &lt;v-row&gt; &lt;v-col cols=\"12\"&gt; &lt;!-- This html is from a safe source --&gt; &lt;h1 style=\"text-align: center\"&gt; {{ title }} &lt;/h1&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- A special query box if the question asks for model/format searching --&gt; &lt;v-row v-if=\"hasModelFormatQuery\"&gt; &lt;v-col cols=\"12\" class=\"ml-4\"&gt; &lt;!-- A list here of selected standards is shown just above the text box --&gt; &lt;div class=\"pl-2\"&gt; &lt;v-chip v-for=\"std in foundModelFormats\" :key=\"std.name\" class=\"ma-2\" close-icon=\"fa fa-trash\" closable @click:close=\"deleteStandard(std.id)\" &gt; {{ std.abbreviation || std.name }} &lt;/v-chip&gt; &lt;/div&gt; &lt;!-- end of standard list --&gt; &lt;v-text-field id=\"searchString\" v-model=\"searchString\" append-inner-icon=\"fa fa-search\" label=\"Search model/formats and terminologies\" variant=\"outlined\" clearable clear-icon=\"fa fa-times-circle\" hide-details class=\"pt-1 mr-10\" color=\"primary\" @click:clear=\"clearResults\" /&gt; &lt;!-- drop-down table for searchResults to go here --&gt; &lt;v-data-table v-if=\" searchResults.length &gt; 0 &amp;&amp; searchString &amp;&amp; searchString.length &gt; 0 \" v-model=\"foundModelFormats\" v-model:search-input=\"searchString\" :headers=\"headers\" :items=\"searchResults\" :items-per-page=\"10\" :footer-props=\"{ 'items-per-page-options': [10, 20, 30, 40, 50] }\" item-key=\"id\" class=\"elevation-1 mr-10\" show-select calculate-widths mobile-breakpoint=\"900\" return-object &gt; &lt;template #[`item.name`]=\"{ item }\"&gt; &lt;div v-if=\"item.name\"&gt; {{ item.name }} &lt;/div&gt; &lt;/template&gt; &lt;template #[`item.abbreviation`]=\"{ item }\"&gt; &lt;div v-if=\"item.abbreviation\"&gt; {{ item.abbreviation }} &lt;/div&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;!-- end of temp results data table --&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- A special query box if the question asks for model/format searching --&gt; &lt;v-row v-if=\"hasTagsQuery\"&gt; &lt;v-col cols=\"12\" class=\"ml-4\"&gt; &lt;!-- A list here of selected tags is shown just above the text box --&gt; &lt;div class=\"pl-2\"&gt; &lt;v-chip v-for=\"tag in recordTags\" :key=\"tag.label\" class=\"ma-2\" :color=\"colors[tag.model]\" variant=\"flat\" close-icon=\"fa fa-trash\" closable @click:close=\"deleteTag(tag.id, tag.model)\" &gt; {{ capitaliseText(tag.label) }} &lt;/v-chip&gt; &lt;/div&gt; &lt;!-- end of tags list --&gt; &lt;v-text-field id=\"searchString\" v-model=\"searchString\" append-inner-icon=\"fa fa-search\" label=\"Search names and synonyms\" variant=\"outlined\" clearable clear-icon=\"fa fa-times-circle\" hide-details class=\"pt-1 mr-10\" color=\"primary\" @click:clear=\"clearResults\" /&gt; &lt;v-data-table v-if=\"tags.length &gt; 0 &amp;&amp; searchString &amp;&amp; searchString.length &gt; 0\" v-model=\"recordTags\" v-model:search-input=\"searchString\" :headers=\"tagHeaders\" :items=\"tags\" :items-per-page=\"10\" :footer-props=\"{ 'items-per-page-options': [10, 20, 30, 40, 50] }\" item-key=\"label\" class=\"elevation-1 mr-10\" show-select calculate-widths mobile-breakpoint=\"900\" return-object &gt; &lt;template #[`item.model`]=\"{ item }\"&gt; &lt;div :class=\"'text-' + colors[item.model]\" class=\"noBreak\"&gt; {{ item.model.toUpperCase().replace(/_/g, \" \") }} &lt;/div&gt; &lt;/template&gt; &lt;template #[`item.label`]=\"{ item }\"&gt; &lt;v-chip :class=\"colors[item.model] + 'text-white noBreak'\" :color=\"colors[item.model]\" variant=\"flat\" &gt; {{ capitaliseText(item.label, item.model) }} &lt;/v-chip&gt; &lt;/template&gt; &lt;template #[`item.synonyms`]=\"{ item }\"&gt; &lt;div v-if=\"item.synonyms\" class=\"font-italic limitWidth\"&gt; {{ item.synonyms.join(\", \") }} &lt;/div&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- end of tags --&gt; &lt;!-- policy query --&gt; &lt;v-row v-if=\"hasPolicyQuery\"&gt; &lt;v-col cols=\"12\" class=\"ml-4\"&gt; &lt;!-- A list here of selected standards is shown just above the text box --&gt; &lt;div class=\"pl-2\"&gt; &lt;v-chip v-for=\"pol in foundPolicies\" :key=\"pol.name\" class=\"ma-2\" close-icon=\"fa fa-trash\" closable @click:close=\"deletePolicy(pol.id)\" &gt; {{ pol.abbreviation || pol.name }} &lt;/v-chip&gt; &lt;/div&gt; &lt;!-- end of standard list --&gt; &lt;v-text-field id=\"searchString\" v-model=\"searchString\" append-inner-icon=\"fa fa-search\" label=\"Search policies\" variant=\"outlined\" clearable clear-icon=\"fa fa-times-circle\" hide-details class=\"pt-1 mr-10\" color=\"primary\" @click:clear=\"clearResults\" /&gt; &lt;!-- drop-down table for searchResults to go here --&gt; &lt;v-data-table v-if=\" searchResults.length &gt; 0 &amp;&amp; searchString &amp;&amp; searchString.length &gt; 0 \" v-model=\"foundPolicies\" v-model:search-input=\"searchString\" :headers=\"headers\" :items=\"searchResults\" :items-per-page=\"10\" :footer-props=\"{ 'items-per-page-options': [10, 20, 30, 40, 50] }\" item-key=\"id\" class=\"elevation-1 mr-10\" show-select calculate-widths mobile-breakpoint=\"900\" return-object @item-selected=\"itemSelected($event)\" &gt; &lt;template #[`item.name`]=\"{ item }\"&gt; &lt;div v-if=\"item.name\"&gt; {{ item.name }} &lt;/div&gt; &lt;/template&gt; &lt;template #[`item.abbreviation`]=\"{ item }\"&gt; &lt;div v-if=\"item.abbreviation\"&gt; {{ item.abbreviation }} &lt;/div&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;!-- end of temp results data table --&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- end of policy query --&gt; &lt;!-- question options --&gt; &lt;v-row class=\"align-stretch justify-center fill-height\"&gt; &lt;v-col v-for=\"item in questions\" :key=\"item.id\" cols=\"3\"&gt; &lt;v-card class=\"full-width d-flex align-center text-center flex-column questionCard justify-center\" height=\"130\" elevation=\"4\" :color=\"item.color\" :class=\"[ { 'cardXtraSmall pa-0': $vuetify.display.xsOnly, 'cardSmall pa-2': $vuetify.display.smOnly, 'cardMedium pa-2': $vuetify.display.mdAndUp, 'cardLarge pa-4': $vuetify.display.lgAndUp, 'cardXtraLarge pa-4': $vuetify.display.xlOnly, }, ]\" @click=\" processLink( item.link, item.query, item.message, item.refined, item.breadcrumbMod, item.role, item.restrict, ) \" &gt; &lt;div class=\"d-flex align-center\"&gt; &lt;v-card-text class=\"text-white font-weight-medium text-xl-h4 text-lg-h5 text-md-h5 text-sm-h5 text-xs-h5 questionText\" &gt; &lt;span&gt; {{ item.question }} &lt;/span&gt; &lt;/v-card-text&gt; &lt;/div&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- question footer --&gt; &lt;v-row&gt; &lt;v-col cols=\"12\"&gt; &lt;p style=\"text-align: center\"&gt;{{ footer }}&lt;/p&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- Potentially annoy the user by stopping to ask if they want to carry on due to few results --&gt; &lt;v-dialog v-model=\"lowResultsStoppage\" persistent&gt; &lt;v-card&gt; &lt;v-card-title class=\"text-h5\"&gt; Fewer than 10 {{ getCurrentRegistry }} records fit your criteria? &lt;/v-card-title&gt; &lt;v-card-text&gt; How would you like to proceed? Select \"dismiss\" to retry your selection. Or, you may go to the results. &lt;/v-card-text&gt; &lt;v-card-actions&gt; &lt;v-spacer /&gt; &lt;v-btn color=\"blue-darken-1\" variant=\"text\" persistent @click=\" lowResultsStoppage = false; iDontCare = true; \" &gt; Dismiss &lt;/v-btn&gt; &lt;v-btn color=\"blue-darken-1\" variant=\"text\" persistent @click=\"goToResults\" &gt; View results &lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-container&gt; &lt;/template&gt; &lt;script&gt; import stringUtils from \"@/utils/stringUtils\"; import questionSets from \"@/data/questionPageData.json\"; import { mapActions, mapGetters } from \"vuex\"; import Loaders from \"@/components/Loaders/Loaders.vue\"; import multiTagFilter from \"@/lib/GraphClient/queries/multiTagsFilter/multiTagsFilterBrief.json\"; import GraphClient from \"@/lib/GraphClient/GraphClient\"; import tagsQuery from \"@/lib/GraphClient/queries/geTags.json\"; import parentsQuery from \"@/lib/GraphClient/queries/getParentPolicies.json\"; import Breadcrumbs from \"@/components/Navigation/Breadcrumbs.vue\"; import ResultPreviewBanner from \"@/components/Results/ResultPreviewBanner.vue\"; const graphClient = new GraphClient(); /* * searchQuery is a query that will be used for getting additional info., e.g. models/formats, which will constrain * the user's search to some special case. It will be used to create a text search box on the page when the questions * are loaded. * searchString is whatever search term is to be passed to the searchQuery. * query is simply some params which must be passed to the multiTagFilter when the question is clicked upon. */ export default { name: \"QuestionPage\", components: { ResultPreviewBanner, Loaders, Breadcrumbs }, mixins: [stringUtils], data: () =&gt; { return { clear: false, watchRecordTags: true, questions: {}, searchQuery: {}, hasModelFormatQuery: false, hasTagsQuery: false, hasPolicyQuery: false, searchString: null, searchResults: [], recordTags: [], tags: [], loading: false, foundModelFormats: [], foundPolicies: [], title: \"\", footer: \"\", lowResultsStoppage: false, iDontCare: false, currentBreadcrumb: null, restrict: null, // This is silly, but I was in a rush and had enough with fighting javascript; registrySwitch: { database: \"Database\", policy: \"Policy\", standard: \"Standard\", collection: \"Collection\", }, headers: [ { title: \"Name\", sortable: false, value: \"name\", }, { title: \"Abbreviation\", sortable: false, value: \"abbreviation\", }, ], tagHeaders: [ { title: \"Type of keyword\", sortable: false, value: \"model\", }, { title: \"Name\", sortable: false, value: \"label\", }, { title: \"Definition\", sortable: false, value: \"definitions[0]\", filterable: false, }, { title: \"Alternative names\", sortable: false, value: \"synonyms\", }, ], colors: { domain: \"domain_color\", taxonomy: \"taxonomic_color\", subject: \"subject_color\", user_defined_tag: \"tags_color\", }, }; }, computed: { ...mapGetters(\"multiTagsStore\", [ \"getFairSharingRecords\", \"getCurrentRegistry\", \"getQueryParams\", \"getSelectedTags\", ]), ...mapGetters(\"navigationStore\", [\"getRouteQuery\", \"getPreviousLocation\"]), }, watch: { $route() { this.getQuestions(); }, getFairSharingRecords() { if ( this.getFairSharingRecords.length &gt; 0 &amp;&amp; this.getFairSharingRecords.length &lt;= 10 &amp;&amp; !this.iDontCare &amp;&amp; !this.loading ) { this.lowResultsStoppage = true; } }, async searchString(val) { if (!val || val.length &lt; 3) { return; } this.searchResults = []; val = val.trim(); await this.getResults(val); }, // Running the query every time user selects a new subject, domain etc. async recordTags(val) { let _module = this; if (!_module.watchRecordTags) { return; } _module.loading = true; let queryParam = _module.generateQuery(val); await _module.fetchMultiTagData(queryParam); // TODO: Handle errors from the server. _module.recordsFound = _module.getFairSharingRecords; _module.$store.commit(\"multiTagsStore/setQueryParams\", queryParam); _module.$store.commit(\"multiTagsStore/setSelectedTags\", val); _module.loading = false; }, // Running the query every time user selects a new model/format async foundModelFormats(val) { let _module = this; _module.loading = true; let ids = []; let names = []; val.forEach(function (format) { ids.push(format.id); names.push(format.name); }); let query = _module.getQueryParams; if (ids.length &gt; 0) { query.dataFormatsAndTerminologies = ids; } else { delete query.dataFormatsAndTerminologies; } this.$store.commit( \"navigationStore/setComplianceState\", names.join(\", \"), ); await this.fetchMultiTagData(query); _module.loading = false; }, async foundPolicies(val) { let _module = this; _module.loading = true; let ids = []; let names = []; val.forEach(function (format) { ids.push(format.id); names.push(format.name); }); let query = _module.getQueryParams; if (ids.length &gt; 0) { query.policyRecommendations = ids; } else { delete query.policyRecommendations; } this.$store.commit( \"navigationStore/setPolicyComplianceState\", names.join(\", \"), ); await this.fetchMultiTagData(query); _module.loading = false; }, }, mounted() { let _module = this; _module.getQuestions(); }, methods: { ...mapActions(\"multiTagsStore\", [\"fetchMultiTagData\", \"resetMultiTags\"]), /* * This is what's executed when the user arrives at a new question. */ async getQuestions() { this.searchString = null; let questionData = questionSets.questionSets.find( (q) =&gt; parseInt(q[\"path\"]) === parseInt(this.$route.params.id), ); this.currentBreadcrumb = JSON.parse( JSON.stringify(questionData.breadcrumb), ); this.questions = JSON.parse(JSON.stringify(questionData.questions)); this.searchQuery = questionData.searchQuery; this.hasModelFormatQuery = questionData.hasModelFormatQuery; this.hasTagsQuery = questionData.hasTagsQuery; this.hasPolicyQuery = questionData.hasPolicyQuery; // TODO: The work related to this is in progress // The current page isn't a link, only previous pages. this.title = questionData.title; this.footer = questionData.footer; if (questionData.clear) { this.clear = true; this.$store.commit( \"navigationStore/clearPreviousNavigation\", `/${this.$route.params.id}`, ); this.$store.commit( \"navigationStore/sliceBreadcrumb\", `/${this.$route.params.id}`, ); this.foundPolicies = []; this.foundModelFormats = []; /* v8 ignore start */ } else { this.clear = false; } /* v8 ignore stop */ // If they're arriving somewhere where a previous query is defined it should be retrieved from the store. // BUT: To prevent users complaining the result is \"wrong\", the query has to be pushed to the next question in // line when leaving, rather than the current one. So, when arriving at a question it will already have a // previous query set and it needs to be triggered only if going backwards (or each query will be run twice // when advancing through the questions). let previousQuery; let _module = this; try { previousQuery = JSON.parse( JSON.stringify(this.getRouteQuery[this.$route.params.id]), ); } catch { // Fails on initial screen because getRouteQuery hasn't been defined. previousQuery = {}; } // Sometimes the previous location could be something like \"/refine\" let previousLocation = Number.parseInt( this.getPreviousLocation.replace(\"/\", \"\"), ); // We're coming from results, refinement or whatever, that is named rather than numbered if (isNaN(previousLocation)) { previousLocation = 9999; } let currentLocation = Number.parseInt(this.$route.params.id); let prevLength = Number.parseInt(Object.keys(previousQuery).length); // This is because the previous query needs only to be loaded when going backwards. if (prevLength &gt; 0 &amp;&amp; previousLocation &gt; currentLocation) { // Set up the selected tags. The store should be checked only if some were defined in the query. // If none are in the query then the store must be cleared (see 'else'). _module.watchRecordTags = false; if ( \"subjects\" in previousQuery || \"domains\" in previousQuery || \"userDefinedTags\" in previousQuery || \"taxonomies\" in previousQuery ) { if (_module.getSelectedTags) { _module.getSelectedTags.forEach(function (tag) { if ( _module.recordTags.filter((x) =&gt; x.label === tag.label) .length === 0 ) { _module.recordTags.push(tag); } }); } // Should tags be cleared here (as in the else, below) also? } else { _module.$store.commit(\"multiTagsStore/setSelectedTags\", []); _module.recordTags = []; } if (\"dataFormatsAndTerminologies\" in previousQuery) { // TODO: Is any setup even necessary here? } else { _module.$store.commit(\"navigationStore/setComplianceState\", []); _module.foundModelFormats = []; } // Load the previous query. _module.$store.commit(\"multiTagsStore/setQueryParams\", previousQuery); _module.loading = true; await _module.fetchMultiTagData(previousQuery); _module.loading = false; // We should be going backwards at this point // TODO: Find queries in the routeQuery store further advanced than the current click target, and clear them. // TODO: This could probably go in the store. _module.watchRecordTags = true; this.$store.commit( \"navigationStore/clearPreviousNavigation\", currentLocation, ); } else if (previousLocation &gt; currentLocation) { // Empty query, so results should be cleared, but only whilst going backwards. this.resetMultiTags(); } // At this point the user is going _forwards_ but there still might be tags hanging around because they've // jumped backwards past e.g. a subject/domain selector and then forward again! else { if ( \"subjects\" in this.getQueryParams || \"domains\" in this.getQueryParams || \"userDefinedTags\" in this.getQueryParams || \"taxonomies\" in this.getQueryParams ) { if (_module.getSelectedTags) { _module.getSelectedTags.forEach(function (tag) { if ( _module.recordTags.filter((x) =&gt; x.label === tag.label) .length === 0 ) { _module.recordTags.push(tag); } }); } } else { _module.recordTags = []; } } }, /* * This code is executed when a user clicks on a question. */ async processLink( link, query, message, refined, breadcrumbMod, role, restrict, ) { if (restrict) { this.$store.commit(\"navigationStore/setRestrict\", restrict); } // Always stash the breadcrumb. // Some questions have a query that must be run when the question is clicked. if (!(Object.keys(query).length === 0)) { this.loading = true; // There may be some additional parameters set as a result of the user having made a special selection // on this page, e.g. when searching for models/formats. if (this.foundModelFormats.length &gt; 0) { let ids = []; let names = []; this.foundModelFormats.forEach(function (format) { ids.push(format.id); names.push(format.name); }); query[\"dataFormatsAndTerminologies\"] = ids; this.$store.commit( \"navigationStore/setComplianceState\", names.join(\", \"), ); } if (this.foundPolicies.length &gt; 0) { let ids = []; let names = []; this.foundPolicies.forEach(function (format) { ids.push(format.id); names.push(format.name); }); query[\"policyRecommendations\"] = ids; this.$store.commit( \"navigationStore/setPolicyComplianceState\", names.join(\", \"), ); } // Merge the previous query in case we're coming from a page where data have already been calculated. let existingQueryCopy = JSON.parse(JSON.stringify(this.getQueryParams)); let mergedQuery = { ...existingQueryCopy, ...query }; await this.fetchMultiTagData(mergedQuery); this.$store.commit(\"multiTagsStore/setQueryParams\", mergedQuery); if (refined) { this.$store.commit(\"multiTagsStore/setRefinedStatus\", refined); } if (message) { this.$store.commit(\"multiTagsStore/setSelectionMessage\", message); } this.loading = false; } // Make the user go through this again if they got a low number of hits. if (this.lowResultsStoppage &amp;&amp; !this.iDontCare) { return; } // Save where we've just been. let path = \"/\" + this.$route.params.id; this.$store.commit(\"navigationStore/setNavigationState\", path); if (role) { this.$store.commit(\"navigationStore/setRole\", role); } // Before leaving the page, stash the query for this particular page. // In some cases a question may need to execute a query on leaving, but clear the results of that on returning, // e.g. a researcher depositing data. let queryCopy = JSON.parse(JSON.stringify(this.getQueryParams)); let nextId = link.replace(\"/\", \"\"); this.$store.commit(\"navigationStore/setRouteQuery\", [nextId, queryCopy]); // And set up the breadcrumbs correctly if (breadcrumbMod) { this.currentBreadcrumb.text = this.currentBreadcrumb.text + breadcrumbMod; } if (this.currentBreadcrumb.text !== \"Finished!\") { this.$store.commit( \"navigationStore/addBreadcrumb\", this.currentBreadcrumb, ); } // Now the links. // In this case, the link is to an external site. /* v8 ignore start */ if (link.match(/^http/)) { window.open(link); } /* v8 ignore stop */ // Whereas here, it's linking to somewhere else within the assistant. else { this.$router.push({ path: link }); } }, async getResults(queryString) { // A different query is run depending on whether hasTagsQuery or hasModelFormatQuery is true. let _module = this; if (_module.hasModelFormatQuery || _module.hasPolicyQuery) { let queryCopy = JSON.parse(JSON.stringify(this.searchQuery)); let filterCopy = JSON.parse(JSON.stringify(multiTagFilter)); if (queryString) { queryCopy[\"q\"] = queryString; } else { this.searchResults = []; return; } filterCopy.queryParam = queryCopy; // This m_t_f execution isn't to do the normal search, just to return databases implementing standards. let searchResults = await graphClient.executeQuery(filterCopy); if (!searchResults.error) { _module.searchResults = searchResults.multiTagFilter; } } else if (_module.hasTagsQuery) { let tagQueryCopy = JSON.parse(JSON.stringify(tagsQuery)); if (queryString) tagQueryCopy.queryParam = { q: queryString }; let taggedRecords = this.getFairSharingRecords.map((x) =&gt; x.id); if (taggedRecords.length) { tagQueryCopy.queryParam.taggedRecords = taggedRecords; } else { delete tagQueryCopy.taggedRecords; } let tags = await graphClient.executeQuery(tagQueryCopy); if (!tags.error) { // This is to take the parents of each tag up a level, so they are included // in the list of available tags from which users may select. let parents = []; tags = tags.searchTags; tags.forEach((tag) =&gt; { tag.parents.forEach((parent) =&gt; { if ( _module.tags.filter((x) =&gt; x.label === parent.label).length === 0 ) { parent.model = tag.model; parents.push(parent); } }); delete tag.parents; }); // TODO: process here to handle nested parents. _module.tags = tags.concat(parents); } } }, clearResults() { this.loading = false; this.tags = []; this.searchResults = []; }, generateQuery(val) { let query = this.getQueryParams; delete query.domains; delete query.subjects; delete query.taxonomies; delete query.userDefinedTags; let domains = val.filter((x) =&gt; x.model === \"domain\").map((x) =&gt; x.label); if (domains.length) { query[\"domains\"] = domains; } let subjects = val .filter((x) =&gt; x.model === \"subject\") .map((x) =&gt; x.label); if (subjects.length) { query[\"subjects\"] = subjects; } let taxonomies = val .filter((x) =&gt; x.model === \"taxonomy\") .map((x) =&gt; x.label); if (taxonomies.length) { query[\"taxonomies\"] = taxonomies; } let user_defined_tags = val .filter((x) =&gt; x.model === \"user_defined_tag\") .map((x) =&gt; x.label); if (user_defined_tags.length) { query[\"userDefinedTags\"] = user_defined_tags; } return query; }, deleteTag(tagId, tagModel) { let currentTags = []; let tagFilter = tagId + tagModel; this.recordTags.forEach(function (tag) { let identifier = tag.id + tag.model; if (identifier !== tagFilter) { currentTags.push(tag); } }); this.recordTags = currentTags; }, deleteStandard(standardId) { this.foundModelFormats = this.foundModelFormats.filter( (el) =&gt; el.id !== standardId, ); }, deletePolicy(policyId) { this.foundPolicies = this.foundPolicies.filter( (el) =&gt; el.id !== policyId, ); }, goToResults() { this.$store.commit( \"navigationStore/addBreadcrumb\", this.currentBreadcrumb, ); this.$router.push(\"/results\"); }, /** * Method to fetch all the parents till the last found parent (id, name, abbreviation) traversing bottom to top of the selected policy * @param item - Selected policy * @return {Promise&lt;void&gt;} - Add the parents if not already present to foundPolicies array */ async itemSelected(item) { let _module = this; parentsQuery.queryParam = { id: item.item.id }; let parents = await graphClient.executeQuery(parentsQuery); parents[\"fairsharingRecord\"][\"parentPolicies\"].forEach((parent) =&gt; { if (!_module.foundPolicies.map((x) =&gt; x.id).includes(parent.id)) { _module.foundPolicies.push(parent); } }); }, }, }; &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; .wrapperClass { position: relative; } .smallScreen { height: auto; } .questionCard { transform: translateY(20px); z-index: 1; animation: smooth-appear 1250ms ease forwards; @keyframes smooth-appear { from { bottom: -300%; opacity: 0; } to { bottom: 20px; opacity: 1; } } } .questionTitle { position: relative; transition-duration: inherit; transform: translateY(-20px); animation: smooth-title 2000ms ease-in forwards; @keyframes smooth-text { 0%, 25% { opacity: 0; } 75%, 100% { opacity: 1; } } } .questionText { transition-duration: inherit; transform: translateX(0); animation: smooth-text 2000ms ease-in forwards; @keyframes smooth-text { 0%, 25% { opacity: 0; } 75%, 100% { opacity: 1; } } } .cardXtraSmall { //height: 30px; padding: 30px; } .cardSmall { //height: 60px; padding: 60px; } .cardMedium { //height: 80px; padding: 80px; } .cardLarge, .cardXtraLarge { min-height: 100px; padding: 50px; } &lt;/style&gt; × Search results Close "},"views_Results_ResultView.vue.html":{"id":"views_Results_ResultView.vue.html","title":"Source: views/Results/ResultView.vue","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Source: views/Results/ResultView.vue &lt;template&gt; &lt;div class=\"d-flex flex-column justify-start align-stretch\"&gt; &lt;Jumbotron /&gt; &lt;div v-if=\"Object.keys(getBreadcrumbs).length &gt; 1\" class=\"mb-10 d-flex flex-row justify-space-around full-width margin-auto\" :class=\"{ 'flex-column align-center': $vuetify.display.smAndDown }\" &gt; &lt;Breadcrumbs /&gt; &lt;/div&gt; &lt;div v-else class=\"mb-10 utilityButtons d-flex flex-row justify-space-around full-width margin-auto\" :class=\"{ 'flex-column align-center': $vuetify.display.smAndDown }\" &gt; &lt;NavigateBackButton /&gt; &lt;ResearchFieldsButton /&gt; &lt;RegistryButton /&gt; &lt;ClearAllSelections :refine-page=\"true\" /&gt; &lt;/div&gt; &lt;ResultTable @is-error=\"noRecords\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapGetters } from \"vuex\"; import Jumbotron from \"@/components/Navigation/Jumbotron\"; import ResultTable from \"@/components/Results/ResultTable.vue\"; import ResearchFieldsButton from \"@/components/Navigation/ResearchFieldsButton.vue\"; import ClearAllSelections from \"@/components/Navigation/ClearAllSelections.vue\"; import RegistryButton from \"@/components/Navigation/RegistryButton.vue\"; import NavigateBackButton from \"@/components/Navigation/NavigateBackButton.vue\"; import Breadcrumbs from \"@/components/Navigation/Breadcrumbs.vue\"; export default { name: \"ResultView\", components: { Breadcrumbs, ResultTable, ClearAllSelections, ResearchFieldsButton, Jumbotron, RegistryButton, NavigateBackButton, }, data() { return { isError: false, }; }, computed: { ...mapGetters(\"navigationStore\", [\"getBreadcrumbs\"]), }, methods: { /** * When results page is accessed directly or refreshed * @param {Boolean} -- value */ noRecords(value) { if (value) this.$router.push(\"/99\"); }, }, }; &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; .utilityButtons { max-width: 820px; } &lt;/style&gt; × Search results Close "},"utils_registryIcon.js.html":{"id":"utils_registryIcon.js.html","title":"Source: utils/registryIcon.js","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Source: utils/registryIcon.js /** * * @param {String} - registryName * @returns {String} - icon name for registry */ const registryIcons = (registry) =&gt; { switch (registry) { case \"Standard\": return \"home_standard\"; case \"Database\": return \"home_db\"; case \"Policy\": return \"home_policies\"; case \"Collection\": return \"home_collections\"; default: return \"home_standard\"; } }; export default registryIcons; × Search results Close "},"utils_registryName.js.html":{"id":"utils_registryName.js.html","title":"Source: utils/registryName.js","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Source: utils/registryName.js /** * * @param {String} - registryName * @returns {String} - display name for registry */ const registryName = (registry) =&gt; { switch (registry) { case \"Standard\": return \"Standards\"; case \"Database\": return \"Databases\"; case \"Policy\": return \"Policies\"; case \"Collection\": return \"Collections\"; default: return registry; } }; export default registryName; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Global Methods currentPath(routeQuery) Parameters: Name Type Description routeQuery Object route query parameters Source: utils/currentPath.js, line 6 Returns: route query parameters Type Object registryIcons() Parameters: Type Description String registryName Source: utils/registryIcon.js, line 6 Returns: icon name for registry Type String registryName() Parameters: Type Description String registryName Source: utils/registryName.js, line 6 Returns: display name for registry Type String × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Classes Classes GraphQLClient Methods currentPath(routeQuery) Parameters: Name Type Description routeQuery Object route query parameters Source: utils/currentPath.js, line 6 Returns: route query parameters Type Object registryIcons() Parameters: Type Description String registryName Source: utils/registryIcon.js, line 6 Returns: icon name for registry Type String registryName() Parameters: Type Description String registryName Source: utils/registryName.js, line 6 Returns: display name for registry Type String × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName FAIRsharing-Assistant Project setup npm install Compiles and hot-reloads for development npm run serve Compiles and minifies for production npm run build Lints and fixes files npm run lint Customize configuration See Configuration Reference. × Search results Close "},"GraphQLClient.html":{"id":"GraphQLClient.html","title":"Class: GraphQLClient","body":" FAIRsharing.org Classes GraphQLClient Global currentPathregistryIconsregistryName Class: GraphQLClient GraphQLClient new GraphQLClient() The GraphQLClient retrieves data from the FAIRSharing API and sends it to the front-end. Be careful, this is a singleton and trying to cast new instances will return the existing instance. Be also careful, its constructor is async !! Source: lib/GraphClient/GraphClient.js, line 12 Returns: to use this object you need to do \"await new ClassName()\" or use .then(callback) Type Promise Methods buildQuery(query) Transform the JSON query into a string for graphQL Parameters: Name Type Description query Object the query coming from the JSON file Source: lib/GraphClient/GraphClient.js, line 61 Returns: {query: queryString} - a valid graphQL query string to execute Type Object &lt;async&gt; executeQuery(query) Execute the given query (coming from a json file, see /queries/getRecords.json) Parameters: Name Type Description query Object the query coming from the JSON file sending to the API. Source: lib/GraphClient/GraphClient.js, line 27 Returns: Type Promise setHeader(jwt) Add the authorization token to the headers Parameters: Name Type Description jwt String the user json web token Source: lib/GraphClient/GraphClient.js, line 130 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
